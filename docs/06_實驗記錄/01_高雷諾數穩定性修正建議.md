# 01\_高雷諾數穩定性修正建議與實驗記錄

**建立時間**: 2026-02-16  
**相關問題**: 模擬在 Re=1000~4000 時發生物理發散 (Velocity Explosion)。  
**錯誤特徵**: "Mosaic Pattern" (棋盤格震盪)、速度場數值爆炸 (> 0.5 lb-units)。

---

## 1. 錯誤分析 (Root Cause Analysis)

根據 `all_cases_summary.json` 的失敗記錄，所有案例皆在 45,000 ~ 50,000 步左右發散，且最大速度超過 0.5 (接近 LBM 極限 $\frac{1}{\sqrt{3}} \approx 0.577$)。

### 1.1 關鍵參數檢查

以 `hybrid_adv_L80_0002.png` 為例：

- `u_max`: 0.05
- `nu`: 0.001
- `L`: ~80 (特徵長度)

根據 MRT-LBM 公式：

$$
	au = 3
u + 0.5
$$

代入 $
u = 0.001$：
$$ au = 0.003 + 0.5 = 0.503 $$

**問題核心**:
當 $ au$ 極度接近 0.5 時，鬆弛參數 $\omega = \frac{1}{	au} \approx 1.988$。
這意味著數值誤差 (特別是高頻噪音) 在每次碰撞後幾乎以全振幅反向放大 (Over-relaxation)，導致典型的 **棋盤格不穩定 (Checkerboard Instability)**，也就是您觀察到的「馬賽克紋」。

### 1.2 棋盤格震盪 (Mosaic Pattern)

這是 LBM 中最常見的數值噪音，通常發生在：

1.  **雷諾數過高 (黏滯係數過低)**：導致 $ au
    ightarrow 0.5$。
2.  **鬼影模態 (Ghost Modes) 未壓制**：高階矩 (Energy, Flux) 累積了過多能量。
3.  **初始衝擊**：入口速度從 0 直接跳到 0.05，產生激波。

---

## 2. 修正建議 (Action Plan)

為了在不大幅增加計算成本的前提下解決此問題，建議採取以下三階段修正。

### 方案 A：實作馬赫數限制與軟重啟 (優先執行)

目前程式碼僅在速度 > 0.5 時崩潰。建議改為監控 **馬赫數 (Mach Number)**，並在偵測到異常時自動降低時間步長或重置。

**建議修改 `src/lbm_mrt_les/engine/simulation_ops.py`：**

```python
# 原本邏輯：if max_v > 0.5: Raise Error
# 修改建議：

# 1. 定義安全閾值 (Safety Threshold)
# LBM 的不可壓縮假設僅在 Ma < 0.1 ~ 0.3 時成立
# u_lb = 0.05 對應 Ma = 0.05 / 0.577 ~= 0.087 (安全)
# 但若局部速度衝到 0.15，代表已經開始不穩
VELOCITY_WARNING_THRESHOLD = 0.15
VELOCITY_CRITICAL_THRESHOLD = 0.30

if max_v > VELOCITY_CRITICAL_THRESHOLD:
    print(f"[Stabilizer] Critical Velocity {max_v:.4f} detected! Simulation Diverged.")
    return {"status": "Failed", "reason": "Mach Number Limit Exceeded"}

if max_v > VELOCITY_WARNING_THRESHOLD:
    # 可以在此處加入自動增加黏滯性的邏輯 (Adaptive Viscosity)
    # 但最簡單的是記錄警告
    print(f"[Warn] High localized velocity: {max_v:.4f}")
```

### 方案 B：調整 MRT 鬼影鬆弛率 (Ghost Moments)

這是解決「馬賽克紋」最有效的方法。

在 `src/lbm_mrt_les/engine/lbm_solver.py` 的 `_init_constants` 中，您目前的設定可能是：

```python
self.S_other = sim_cfg["ghost_moments_s"] # 通常 yaml 設為 1.0 或 1.05
```

**修正建議**：
將鬼影模態的鬆弛率設定為 **1.1 ~ 1.2**。這會強制高頻噪音快速衰減，而不會影響物理黏滯性 (由 $s_{
u}$ 控制)。

請檢查 `configs/Hyper/` 下的 `.yaml` 檔：

```yaml
simulation:
  # 將此值從 1.05 提升至 1.1 或 1.2
  ghost_moments_s: 1.2
```

### 方案 C：增加網格解析度 (Resolution)

若 $
u=0.001$ 導致 $ au=0.503$ 太危險，唯一的物理正確解法是增加解析度 $N$。

- 保持 $Re$ 不變。
- 保持 $u_{lb}$ 不變。
- 將解析度 $N$ 增加 2 倍 ($L 
ightarrow 2L$)。
- 則 $
u$ 必須增加 2 倍 ($
u 
ightarrow 2
u = 0.002$)。
- 新的 $ au = 0.006 + 0.5 = 0.506$ (稍微遠離 0.5，穩定性大幅提升)。

---

## 3. 實驗代碼修改指引

請依照以下步驟修改您的程式碼以增強穩定性。

### 步驟 1: 修改 Config 模板 (`configs/templates/config_template.yaml`)

增加 `ghost_moments_s` 的預設值。

```yaml
simulation:
  ghost_moments_s: 1.2 # 推薦值: 1.1 ~ 1.2
```

### 步驟 2: 修改 `simulation_ops.py` 的監控邏輯

```python
# 檔案: src/lbm_mrt_les/engine/simulation_ops.py

def run_simulation_loop(...):
    # ...
    # 在迴圈內

    # [新增] 監控全場最大速度
    max_v = solver.get_max_velocity() # 需在 solver 實作此 helper

    # 嚴格的馬赫數限制
    if max_v > 0.25: # 約 Ma=0.4
        print(f"[Error] Velocity explosion detected (u={max_v:.4f}). Stopping.")
        return {"status": "Failed", "reason": "Mach Limit (0.25) Exceeded"}

    # [新增] 監控 NaN
    if np.isnan(max_v):
         return {"status": "Failed", "reason": "NaN Detected"}
```

### 步驟 3: 修改 `lbm_solver.py` 增加入口緩衝 (Warm-up Ramp)

避免 $t=0$ 時速度直接從 0 跳到 0.05。

```python
# 檔案: src/lbm_mrt_les/engine/lbm_solver.py

@ti.kernel
def apply_bc(self):
    # 使用平滑啟動函數
    # warmup_steps 建議設為 2000~5000
    factor = 1.0
    if self.frame_count[None] < self.warmup_steps:
        factor = 1.0 - ti.cos(0.5 * 3.14159 * self.frame_count[None] / self.warmup_steps)

    # 應用到入口速度
    u_inlet = self.u_inlet_base * factor
    # ...
```

---

## 4. 總結

1.  **馬賽克紋**是高頻噪音，請透過將 `ghost_moments_s` 調高至 **1.2** 來消除。
2.  **物理發散**是因為 $ au$ 過於接近 0.5。若調整鬆弛率無效，必須**增加解析度**或**降低雷諾數目標**。
3.  建議在 `simulation_ops.py` 中將崩潰閾值從 0.5 降至 **0.25**，提早捕捉錯誤。
